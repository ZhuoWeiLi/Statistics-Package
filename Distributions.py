from math import factorial, fabs, exp
from random import random, shuffle
import matplotlib.pyplot as plt

#Borrowed from G.Fleischer
def C(n,k):
    if k > n or k < 0:
        return 0
    else:
        if k > n//2:
            k = n-k
        res = 1
        for j in range(k):
            res *= n-j
            res //= j+1
    return res

def calcprobability(L, formula):
    """Given an iterable containing 1 or 2 elements and a formula for calculating the probability of an x value,
    return the probability of that x value if there is 1 element in the iterable or the probability of
    that interval of x values if there are 2 elements in the iterable where the first element represents the
    start of the interval and the second element represents the end of the interval, inclusively."""
    if len(L) == 1:
        start = L[0]
        end = start
    elif len(L) == 2:
        start, end = L[0], L[1]
    else:
        print('Invalid, please only enter 1 or 2 arguments in the function')
        return
    
    res = 0
    
    #Calculate the probabilities of all the x values in the interval
    #and add them up
    for x in range(start, end+1): 
        res += formula(x)
        
    return res

class discrete(object):

    def uniform(c,d):
        def formula(a):
            if c <= a <= d:
                return 1/fabs((d-c+1))
            else:
                return 0
        def pdf(*x):
            """Returns the probability of a certain x or interval of x values occuring"""
            return calcprobability(x, formula)
        return pdf

        
    
    def binomial(n,p):
        """Returns the probability density function of the given binomial distribution"""
        if not 0 <= p <= 1:
            print('Invalid, p must be between 0 and 1')
            return
        def formula(a):
            return C(n,a)*p**a*(1-p)**(n-a)
        def pdf(*x):
            return calcprobability(x, formula)
        return pdf

    def hypergeometric(N,n,k):
        """Returns the probability density function of the given hypergeometric distribution"""
        if n > N:
            print('Invalid, n must be smaller or equal to N')
            return
        elif k > N:
            print('Invalid, k must be smaller or equal to N')
            return
        def formula(a):
            return C(k,a)*C(N-k,n-a)/C(N,n)
        def pdf(*x):
            """Returns the probability of a certain x or interval of x values occuring"""
            return calcprobability(x, formula)
        return pdf

    def geometric(p):
        """Returns the probability density function of the given geometric distribution"""
        if not 0 <= p <= 1:
            print('Invalid, p must be between 0 and 1')
            return
        def formula(a):
            if a == 0:
                return 0
            return (1-p)**(a-1)*p
        def pdf(*x):
            """Returns the probability of a certain x or interval of x values occuring"""
            return calcprobability(x, formula)
        return pdf

    def negativebinomial(k,p):
        """Returns the probability density function of the given negative binomial distribution"""
        if not 0 <= p <= 1:
            print('Invalid, p must be between 0 and 1')
            return
        def formula(a):
            return C(a-1,k-1)*p**k*(1-p)**(a-k)
        def pdf(*x):
            """Returns the probability of a certain x or interval of x values occuring"""
            return calcprobability(x, formula)
        return pdf

    def poisson(l):
        """Returns the probability density function of the given poisson distribution"""
        def formula(a):
            return l**a*exp(-l)/factorial(a)
        def pdf(*x):
            """Returns the probability of a certain x or interval of x values occuring"""
            return calcprobability(x, formula)
        return pdf

    def simulate(pdf, num_samples, sample_size = 1, num_intervals = 20):
        """Creates a simulation by taking random points from a given pdf and show
        a histogram representing the frequency of each x value"""
        points = [] #Store the random x values generated 
        cache = [pdf(0)] #Store the cumulative probabiltiies of the probability pdf function
        
        random_nums = [] #Store random numbers between 0 and 1 generated by the random() function and sort them
        for i in range(num_samples*sample_size):
            random_nums.append(random())
        random_nums.sort()
        
        x = 0
        #Map the random nums to an x value using the cumulative probabilities of the probability pdf
        for num in random_nums:
            while num > cache[-1]:
                x+= 1
                cache.append(cache[-1] + pdf(x)) #Keeping adding cumulative pdfs
                #to the cache until it is bigger the current random number, then add the x-value to the points
            points.append(x)
        if sample_size != 1: #Take random samples from the points list if sample size is not 1
            samples = []
            shuffle(points)
            while points:
                sample = []
                for i in range(sample_size):
                    sample.append(points.pop())
                samples.append(sum(sample))
            samples.sort()
        else: #Else each sample has a sample size of one, so points represent samples of sample size 1
            samples = points

        start = min(samples)
        end = max(samples)
        bins = [start]
        interval = (end - start)//num_intervals + 1
        for i in range(num_intervals): #Create the intervals for the histogram
            current = bins[-1] + interval
            bins.append(current)
        

        #Setup histogram and show it
        print('Histogram with {} intervals of {} starting at {}'.format(num_intervals, interval, start))
        plt.hist(samples, bins, histtype = 'bar')
        plt.show()
        
class continuous(object):
    def uniform(c,d):
        def pdf(start, end):
            return 1/fabs((d-c))*(end-start)
        return pdf

    def exponential(l):
        def pdf(start, end):
            return exp(-1*start)-exp(-l*end)
        return pdf
        
        
        
    




        

        
        

